#include <SPI.h>
#include "DW1000Ranging.h"
#include "DW1000.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>

//========================================IPS CONFIG================================================
//#define DEBUG_TRILAT  //prints in trilateration code
//#define DEBUG_DIST     //print anchor distances
#define USING_myAPP  //Using My APPs

#define SPI_SCK 18
#define SPI_MISO 19
#define SPI_MOSI 23
#define DW_CS 4

// connection pins
const uint8_t PIN_RST = 27;  // reset pin
const uint8_t PIN_IRQ = 34;  // irq pin
const uint8_t PIN_SS = 4;    // spi select pin

// TAG antenna delay defaults to 16384
// leftmost two bytes below will become the "short address"
char tag_addr[] = "7D:00:22:EA:82:60:3B:9C";

// variables for position determination
#define N_ANCHORS 9
#define ANCHOR_DISTANCE_EXPIRED 5000  //measurements older than this are ignore (milliseconds)

uint32_t last_anchor_update[N_ANCHORS] = { 0 };   //millis() value last time anchor was seen
float last_anchor_distance[N_ANCHORS] = { 0.0 };  //most recent distance reports

bool anchor_status[N_ANCHORS] = { false };
int anchor_addresses[N_ANCHORS] = { 0 };


float anchor_matrix[N_ANCHORS][3] = {0.0,0.0,0.0};
//   //list of anchor coordinates, relative to chosen origin.
//   { 0.0, 0.0, 1.5 },  //Anchor labeled #1
//   { 5.5, 1.92, 1.5 },  //Anchor labeled #2
//   { 15.0, 0.0, 1.5 },  //Anchor labeled #3
//   { 28.04, 1.92, 1.5 },  //Anchor labeled #4
//   { 55.02, 0.0, 1.5 },  //Anchor labeled #5
//   { 28.04, 1.92, 1.5 },  //Anchor labeled #6
//   { 55.02, 0.0, 1.5 },  //Anchor labeled #7
//   { 28.04, 1.92, 1.5 },  //Anchor labeled #8
//   { 55.02, 0.0, 1.5 },  //Anchor labeled #9
// };  //Z values are ignored in this code

float current_tag_position[2] = { 0.0, 0.0 };  //global current position (meters with respect to anchor origin)
float current_distance_rmse = 0.0;             //rms error in distance calc => crude measure of position error (meters).  Needs to be better characterized

float X_filtered, Y_filtered;  // Variabel untuk posisi saat ini

//======================================== Display config ================================================

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define UP_BUTTON_PIN 12    // Pin untuk tombol "Up"
#define DOWN_BUTTON_PIN 14  // Pin untuk tombol "Down"
#define BACK_BUTTON_PIN 13  // Pin untuk tombol "Back"
#define OK_BUTTON_PIN 26    // Pin untuk tombol "OK"

#define DEBOUNCE_DELAY 250 // Waktu debounce dalam milidetik
#define LONG_PRESS_DELAY 2000 // Waktu penekanan lama dalam milidetik untuk masuk mode konfigurasi
#define IDLE_TIMEOUT 60000 // Waktu tanpa respons tombol sebelum menampilkan logo (dalam ms)

#define EEPROM_ADDR_ANCHOR 0 // Alamat memori EEPROM untuk menyimpan posisi anchor

// 'AMR', 128x64px
const unsigned char logo_AMR [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x80, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x80, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xc0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xc0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x70, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x70, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x38, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x1c, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x1c, 0x00, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x3e, 0x01, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x7e, 0x01, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7f, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xff, 0x86, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xff, 0x8e, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xcc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x01, 0xff, 0xd8, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x7f, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x7f, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0x8c, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x8c, 0x60, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x8c, 0x62, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x80, 0x60, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0x80, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0x80, 0x60, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x19, 0x92, 0x62, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x39, 0x92, 0x73, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xe6, 0x33, 0x98, 0x66, 0x36, 0x7e, 0x31, 0x9d, 0xb9, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xe6, 0x33, 0x18, 0x67, 0x66, 0x7e, 0x31, 0x89, 0x99, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xe7, 0x3b, 0x98, 0x63, 0x76, 0x7e, 0x31, 0x89, 0x99, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf7, 0x39, 0xcd, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x63, 0x31, 0x89, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x63, 0x31, 0xd9, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

int currentAnchorIndex = 0; // Index anchor yang sedang dipilih
int currentConfigIndex = 0; // Index konfigurasi yang sedang dipilih (0: X, 1: Y, 2: Z)
bool configMode = false; // Mode konfigurasi

unsigned long lastDebounceTime = 0;  // Waktu terakhir tombol ditekan
unsigned long debounceDelay = DEBOUNCE_DELAY;    // Waktu debouncing (dalam ms)
unsigned long lastButtonPressTime = 0; // Waktu terakhir tombol ditekan
bool idleMode = false; // Mode idle (menampilkan logo)

void setup() {
  Serial.begin(115200);

  pinMode(UP_BUTTON_PIN, INPUT_PULLUP);
  pinMode(DOWN_BUTTON_PIN, INPUT_PULLUP);
  pinMode(BACK_BUTTON_PIN, INPUT_PULLUP);
  pinMode(OK_BUTTON_PIN, INPUT_PULLUP);
    // Inisialisasi EEPROM
  EEPROM.begin(N_ANCHORS * 3 * sizeof(float));

  //initialize configuration
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  DW1000Ranging.initCommunication(PIN_RST, PIN_SS, PIN_IRQ);  //Reset, CS, IRQ pin

  DW1000Ranging.attachNewRange(newRange);
  DW1000Ranging.attachNewDevice(newDevice);
  DW1000Ranging.attachInactiveDevice(inactiveDevice);

  // start as tag, do not assign random short address

  DW1000Ranging.startAsTag(tag_addr, DW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.display();
  delay(1000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  loadAnchorPositions(anchor_matrix); // Memuat posisi anchor dari EEPROM saat program dimulai

#ifdef USING_myAPP
  // Mengirim data Posisi anchor melalui serial dalam satu baris yang dipisahkan dengan koma
  Serial.print(N_ANCHORS);  // Menggunakan 1 digit di belakang koma untuk X
  Serial.print(",");

  for (int i = 0; i < N_ANCHORS; i++) {
    Serial.print(anchor_matrix[i][0], 1);  // Menggunakan 1 digit di belakang koma untuk X
    Serial.print(",");
  }

  // Mengirim data melalui serial dalam satu baris yang dipisahkan dengan koma
  for (int i = 0; i < N_ANCHORS; i++) {
    Serial.print(anchor_matrix[i][1], 1);  // Menggunakan 1 digit di belakang koma untuk Y
    // Menambahkan karakter baru setelah setiap baris kecuali yang terakhir
    if (i < (N_ANCHORS - 1)) {
      Serial.print(",");
    }
  }
  Serial.println("");
  delay(1000);
#endif

}

void loop() {
  if (idleMode) {
    // Mode idle, menampilkan logo
    display.clearDisplay();
    display.drawBitmap(0, 0, logo_AMR, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE);
    display.display();

    // Periksa jika tombol OK ditekan untuk kembali ke menu anchor
    if (digitalRead(UP_BUTTON_PIN) == 0 || digitalRead(DOWN_BUTTON_PIN) == 0 || digitalRead(BACK_BUTTON_PIN) == 0 || digitalRead(OK_BUTTON_PIN) == LOW) {
      idleMode = false; // Keluar dari mode idle
      lastButtonPressTime = millis(); // Perbarui waktu terakhir tombol ditekan
      displayMenu(); // Tampilkan menu anchor
    }
    DW1000Ranging.loop();
  } else {
    displayMenu(); // Tampilkan menu

    // Periksa tombol yang ditekan dengan debounce
    if (millis() - lastDebounceTime > debounceDelay) {
      if (!configMode && digitalRead(BACK_BUTTON_PIN) == LOW && digitalRead(OK_BUTTON_PIN) == LOW) {
        enterConfigMode(); // Masuk mode konfigurasi
      }
      else if (configMode) {
        handleConfigMode(); // Handle mode konfigurasi
      }
      else {
        handleNormalMode(); // Handle mode normal
        DW1000Ranging.loop();
      }
    }
    // Periksa apakah sudah waktunya untuk masuk ke mode idle
    if (millis() - lastButtonPressTime > IDLE_TIMEOUT) {
      idleMode = true; // Masuk mode idle
    }
  }
}


// collect distance data from anchors, presently configured for 4 anchors
// solve for position if all four current

void newRange() {
  int i;
  int index = DW1000Ranging.getDistantDevice()->getShortAddress() & 0x0f; 

  if (index > 0) {
    last_anchor_update[index - 1] = millis();
    float range = DW1000Ranging.getDistantDevice()->getRange();
    last_anchor_distance[index - 1] = range;
    //if (range < 0.0 || range > 30.0) last_anchor_update[index - 1] = 0;
  }
  
  int detected = 0;
  int nearest_anchors[3]; // Array untuk menyimpan indeks 3 anchor terdekat
  float nearest_distances[3]; // Array untuk menyimpan jarak dari 3 anchor terdekat

  // Menginisialisasi array jarak terdekat dengan jarak yang besar
  for (i = 0; i < 3; i++) {
    nearest_distances[i] = 1000000.0; // Anggap jarak maksimum
  }

  // Memilih 3 anchor terdekat
  for (i = 0; i < N_ANCHORS; i++) {
    if (millis() - last_anchor_update[i] > ANCHOR_DISTANCE_EXPIRED) last_anchor_update[i] = 0;
    if (last_anchor_update[i] > 0) {
      detected++;
      // Memeriksa apakah jarak saat ini lebih dekat dari jarak yang disimpan
      for (int j = 0; j < 3; j++) {
        if (last_anchor_distance[i] < nearest_distances[j]) {
          // Memperbarui jarak terdekat dan indeks anchor
          for (int k = 2; k > j; k--) {
            nearest_distances[k] = nearest_distances[k - 1];
            nearest_anchors[k] = nearest_anchors[k - 1];
          }
          nearest_distances[j] = last_anchor_distance[i];
          nearest_anchors[j] = i;
          break;
        }
      }
    }
  }

#ifdef DEBUG_DIST
  char line[60];
  snprintf(line, sizeof line, "%d > d: %6.2f | %d > %6.2f | %d > %6.2f",nearest_anchors[0],nearest_anchors[1],nearest_anchors[2], nearest_distances[0], nearest_distances[1], nearest_distances[2]);
  Serial.println(line);
#endif

  // Perhitungan trilaterasi menggunakan 3 anchor terdekat
  if (detected >= 3) {
    trilateration(anchor_matrix[nearest_anchors[0]][0], anchor_matrix[nearest_anchors[0]][1], nearest_distances[0],
                  anchor_matrix[nearest_anchors[1]][0], anchor_matrix[nearest_anchors[1]][1], nearest_distances[1],
                  anchor_matrix[nearest_anchors[2]][0], anchor_matrix[nearest_anchors[2]][1], nearest_distances[2]);

    kalmanFilter(current_tag_position[0], current_tag_position[1], X_filtered, Y_filtered);
    Serial.print(X_filtered);
    Serial.write(',');
    Serial.println(Y_filtered);
  }
}

void newDevice(DW1000Device *device) {
  Serial.print("Device added: ");
  Serial.println(device->getShortAddress(), HEX);
}

void inactiveDevice(DW1000Device *device) {
  Serial.print("delete inactive device: ");
  Serial.println(device->getShortAddress(), HEX);
}